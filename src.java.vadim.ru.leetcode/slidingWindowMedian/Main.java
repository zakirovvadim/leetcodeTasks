package slidingWindowMedian;

import java.util.*;

/**
 * Используется алгоритм с двумя приоритетными очередями, следует заменить на TreeSet, так как в литкоде с приоритиКью падаетс TLE.
 *
 * Кратко, нужно эффективно отсортировать значения в окне для вывода среднего значения.
 *
 * Для этого есть две очереди с сортировкой максимального значения и минимального. В максимлаьное кладем меньшие числа, в мин. очередь кладем большие числа
 * Те. если разделить 1.2.3.4 на две очереди в максимальной будут 1 и 2, и макс значчение тут 2, а мин. очереди будут 3 и 4, и мин. значение тут 3,
 * получается середина из двух чисел (если окно нечетное) одного массива с получением значений от О(1) из каждой очереди.
 * Разница между двумя очередями должна быть не более чем в 1 элемент, елси нет, то делаем балансировку, убираем лишний элемент и кладем его в другую очередь
 *
 * Подробный алгоритм
 * Итерируемся по массиву
 * Добавляем значение в любую очереь в первый раз
 * Балансируем
 */
public class Main {


    public static void main(String[] args) {
        int[] nums = new int[]{2147483647,1,2,3,4,5,6,7,2147483647};
        Main main = new Main();
        double[] ints = main.medianSlidingWindow(nums, 2);
        for (int i = 0; i < ints.length; i++) {
            System.out.println(ints[i]);
        }
    }
    Queue<Integer> minHeap;
    Queue<Integer> maxHeap;
    public Main() {
        minHeap = new PriorityQueue<>(); // очередь для получения меньшего числа среди больших
        maxHeap = new PriorityQueue<>(Collections.reverseOrder()); // очередь для получения большего числа среди меньших
    }

    public double[] medianSlidingWindow(int[] nums, int k) {
        int left = 0;
        double[] result = new double[nums.length - k + 1]; // устанавливаем результирующий массив, высчитываем его длину
        for (int i = 0; i < nums.length; i++) {
            add(nums[i]); // добавляем в
            if (k == i - left + 1) {
                result[i - k + 1] = findMedian(); // присваиваем результат вычисления среднего
                remove(nums[left]); // удаляем число из очередей, если оно вышло из окна
                left++; // двигаем левый офсет
            }
        }
        return result;
    }

    public void add(int num) {
        if (maxHeap.isEmpty() || num <= maxHeap.peek()) { // для первого раза добавляем сюда, т.е. если пустая очереь, после проверяем, если пришедшее число меньше или равно максимальному числу среди меньших, добавляем в эту очередь, иначе в другую
            maxHeap.add(num);
        } else {
            minHeap.add(num);
        }
        balance(); // балансируем, так как нужно осблюдать разницу в размерах не болшечем на один.
    }

    public void balance() {
        if (maxHeap.size() > minHeap.size() + 1) { // если размер одного больше чем другого на его размер + 1, перетаскиваем значение туда где не хватает
            minHeap.add(maxHeap.poll());
        } else if (minHeap.size() > maxHeap.size()) { // и наооборот
            maxHeap.add(minHeap.poll());
        }
    }

    public void remove(int num) { // удаляем значение
        if (num <= maxHeap.peek()) { // если число меньше максимального среди меньших, значит оно в этой очереди,
            maxHeap.remove(num); // удаляем конкретное значение, удаление должно быть лог от н
        } else {
            minHeap.remove(num); // и наоборот
        }
        balance(); // балансируем
    }

    public double findMedian() {
        if (maxHeap.size() > minHeap.size()) return maxHeap.peek(); // если очереди расопложись так 4,5,___6, и окно равно трем, значит среднее можно просто вытащить из левой очереди
        if (minHeap.size() > maxHeap.size()) return minHeap.peek(); // и наооборот, если 4___5,6, начит вытащим из другой очереди просто взяв ее из головы
        return maxHeap.peek() /2.0 + minHeap.peek() / 2.0; // если очереди равны, значи в окне четное количество и нужно суммировать два серединных числа и делить на два. Раздельное деление связано с переполнением  int.
    }
}
