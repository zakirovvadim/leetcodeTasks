package search_in_rotated_sorted_array_2;

/**
 * Алгоритм схож с оригинальной задачей. Разница в том, что мы не знаем какие числа могут быть справа и слева от середины, так как они имеют дубликаты.
 * Но мы знаем, что попав на середину, мы можем сравнить значение со значением в первом индексе, и если они равны, значи наш таргет точно не мид и точно не первыфй элемент.
 * Дальше мы сдвигаем left вправо, и также по циклу считаем мид и сравниваем. Если же мид и лефт не равны, значит мы можем использовать алгоритм из оригинальной задачи.
 * Т.е. определяем левую часть или правую, для этого сравниваем лефт с мидлом, если больше то правая часть, меньше - левая.
 * Далее смотрим, входит ли наш таргет в диапазон для левой части это больше или равно начала и меньше мида, для правой - больше мида и меньше или равно правого офсета.
 * В соотвтетсвии с условием двигаем левый или правый офсет.
 */
public class Main {
    public static void main(String[] args) {
        int[] nums = new int[]{2,5,6,0,0,1,2};
        System.out.println(search(nums, 10));
    }

    public static boolean search(int[] nums, int target) {
        int low = 0;
        int high = nums.length - 1;

        while (low <= high) {
            int mid = (low + high) / 2; // находим мид
            if (nums[mid] == target) return true; // таргет равен миду
            if(nums[low] < nums[mid]) { // лефт меньше мида - левая часть
                if ((nums[low] <= target) && (target < nums[mid])) { // проверяем входит ли диапазон в промежуток между лефт и мидом
                    high = mid - 1; // двигаем правый офсет в мид
                } else low = low + 1; // иначе двигаем левый офсет в мид
            } else if (nums[low] > nums[mid]) { // лефт больше, значит это ротейтед массив и это правая часть
                if ((nums[mid] < target) && (target <= nums[high])) { // проверяем входит ли диапазон в промежуток между mid и high
                    low = low + 1; // двигаем левый оффсет в мид
                } else high = mid - 1; // иначе двигаем правый оффсет в мид
            } else {
                low++; // мид и левый офсет равны, значит лефт точно не равен таргету, сдвигаем левый офсет на +1
            }
        }
        return false;
    }
}
