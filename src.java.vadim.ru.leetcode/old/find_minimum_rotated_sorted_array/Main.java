package old.find_minimum_rotated_sorted_array;

/**
 * Алгоритм схож с оригинальной задачей поиска числа в повернутом массиве.
 * Здесь мы инициализируем дополнительную переменную min, в которую будем записывать сравнение минимального значения.
 * В таком же цикле идет условие если элемент с индексом лоу меньше элемента с индексом хай, перед возвратом, олжны сравнить с переменной, хранящей минимальное значение.
 * Смысл алгоритма в том, чтобы сдвигать лоу или хай друг к другу к найденному миду - середине и сравнивать значение середины с записанным минимальным значением в min.
 * Т.е. если мы попадаем в перевернуты массив, т.е. мид указывает на значение больше чем элемент под индексом лоу, значит сравниваем значение под мидом с min и записываем в последний
 * минимальное из них. 
 * Далее определяем куда двигать краевые офсеты, если мид значение больше лоу значит двигаем в право, елси меньше, хай двигаем влево, и снова вычисляем мид и сравниваем с min.
 */
public class Main {
    public static void main(String[] args) {
        int[] nums = new int[]{3,4,5,1,2};
        System.out.println(findMin(nums));
    }

    public static int findMin(int[] nums) {
      int low = 0;
      int high = nums.length - 1;
      int min = nums[0]; // переменная для минимального значения

      while (low <= high) {
          if (nums[low] < nums[high]) return Math.min(min, nums[low]); // если лоу меньше хай, значит мы пересекли 
          // границу перевернутого массива и оригинального массива и наш офсет лоу теперь мб первым минимальным элементом
          int mid = (low + high) / 2; // находим мид
          min = Math.min(min, nums[mid]); // записываем в переменую минимальное значение из найденнйо середины и предыдущего значения мин.
          if (nums[mid] >= nums[low]) { // определяем направления сдвига офсета и в какой части массива мы находимся
              low = mid + 1;
          } else {
              high = mid - 1;
          }
      }
      return min;
    }
}
