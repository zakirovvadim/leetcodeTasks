package newStart;
/*
Задача: дан ряд мест, 1 – место занято, 0 – свободно.
Нужно вернуть максимальное возможное расстояние от нового зрителя
до ближайшего уже сидящего зрителя, если он выбирает место оптимально.

Идея решения (O(n), O(1) память):

1. Вся логика сводится к анализу подряд идущих блоков из нулей:
   - блок нулей в начале массива (до первой 1);
   - блоки нулей между двумя единицами;
   - блок нулей в конце массива (после последней 1).

2. Если блок нулей в КРАЮ (в начале или в конце):
   - оптимальное место — на самом дальнем конце блока,
   - расстояние до ближайшего зрителя = длина блока.

3. Если блок нулей между ДВУМЯ единицами (в середине):
   - оптимальное место — посередине блока,
   - расстояние до ближайшего зрителя = ceil(L / 2),
     где L — длина блока (количество подряд идущих 0).

4. Реализация:
   - Сначала отдельно обрабатываем ведущие нули:
     считаем длину первого блока нулей, сохраняем её в max
     и начинаем основной цикл с первой единицы.
   - В основном цикле идём от k до конца:
       • считаем длину текущего блока нулей в переменной count;
       • если это последний элемент массива и там 0 — это хвостовой блок,
         обновляем max = max(max, count) (весь блок, так как на краю);
       • для внутренних блоков (между 1) накапливаем count и
         обновляем max через расстояние до ближайшего зрителя:
           max = max(max, ceil(count / 2.0)).

5. В конце возвращаем max — это искомое максимальное расстояние.
*/

public class MaximizeDistanceClosestPerson {
    public int maxDistToClosest(int[] seats) {
        int max = 0;
        int count = 0;
        int k =0;

        if (seats[0] == 0) {
            while(seats[k] == 0) {
                k++;
                count+= 1;
            }
            max = count;
            count = 0;
        }

        for (int i = k; i < seats.length; i++) {
            int s = seats[i];

            if (i == seats.length - 1 && s == 0) {
                count++;
                max = Math.max(count, max);
                break;
            }

            if (s == 1) {
                count=0;
            } else {
                count++;
                max = Math.max((int) Math.ceil(count / 2.0), max);
            }
        }
        return max;
    }
}
